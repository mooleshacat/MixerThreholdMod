GAME HAS LIST OF COMMANDS IT HANDLES, WE CAN HAVE OURS, AND COMPARE TO KNOW WHO HANDLES WHAT ACCESS THIS Console.commands !!

// Token: 0x06000C22 RID: 3106 RVA: 0x00037FB4 File Offset: 0x000361B4
		protected override void Awake()
		{
			base.Awake();
			if (Singleton<Console>.Instance != this)
			{
				return;
			}
			if (Console.commands.Count == 0)
			{
				Console.commands.Add("freecam", new Console.FreeCamCommand());
				Console.commands.Add("save", new Console.Save());
				Console.commands.Add("settime", new Console.SetTimeCommand());
				Console.commands.Add("give", new Console.AddItemToInventoryCommand());
				Console.commands.Add("clearinventory", new Console.ClearInventoryCommand());
				Console.commands.Add("changecash", new Console.ChangeCashCommand());
				Console.commands.Add("changebalance", new Console.ChangeOnlineBalanceCommand());
				Console.commands.Add("addxp", new Console.GiveXP());
				Console.commands.Add("spawnvehicle", new Console.SpawnVehicleCommand());
				Console.commands.Add("setmovespeed", new Console.SetMoveSpeedCommand());
				Console.commands.Add("setjumpforce", new Console.SetJumpMultiplier());
				Console.commands.Add("teleport", new Console.Teleport());
				Console.commands.Add("setowned", new Console.SetPropertyOwned());
				Console.commands.Add("packageproduct", new Console.PackageProduct());
				Console.commands.Add("setstaminareserve", new Console.SetStaminaReserve());
				Console.commands.Add("raisewanted", new Console.RaisedWanted());
				Console.commands.Add("lowerwanted", new Console.LowerWanted());
				Console.commands.Add("clearwanted", new Console.ClearWanted());
				Console.commands.Add("sethealth", new Console.SetHealth());
				Console.commands.Add("settimescale", new Console.SetTimeScale());
				Console.commands.Add("setvar", new Console.SetVariableValue());
				Console.commands.Add("setqueststate", new Console.SetQuestState());
				Console.commands.Add("setquestentrystate", new Console.SetQuestEntryState());
				Console.commands.Add("setemotion", new Console.SetEmotion());
				Console.commands.Add("setunlocked", new Console.SetUnlocked());
				Console.commands.Add("setrelationship", new Console.SetRelationship());
				Console.commands.Add("addemployee", new Console.AddEmployeeCommand());
				Console.commands.Add("setdiscovered", new Console.SetDiscovered());
				Console.commands.Add("growplants", new Console.GrowPlants());
				Console.commands.Add("setlawintensity", new Console.SetLawIntensity());
				Console.commands.Add("setquality", new Console.SetQuality());
				Console.commands.Add("bind", new Console.Bind());
				Console.commands.Add("unbind", new Console.Unbind());
				Console.commands.Add("clearbinds", new Console.ClearBinds());
				Console.commands.Add("hideui", new Console.HideUI());
				Console.commands.Add("disable", new Console.Disable());
				Console.commands.Add("enable", new Console.Enable());
				Console.commands.Add("endtutorial", new Console.EndTutorial());
				Console.commands.Add("disablenpcasset", new Console.DisableNPCAsset());
				Console.commands.Add("showfps", new Console.ShowFPS());
				Console.commands.Add("hidefps", new Console.HideFPS());
				Console.commands.Add("cleartrash", new Console.ClearTrash());
				Console.commands.Add("playcutscene", new Console.PlayCutscene());
			}
			foreach (KeyValuePair<string, Console.ConsoleCommand> keyValuePair in Console.commands)
			{
				Console.Commands.Add(keyValuePair.Value);
			}
			Player.onLocalPlayerSpawned = (Action)Delegate.Remove(Player.onLocalPlayerSpawned, new Action(this.RunStartupCommands));
			Player.onLocalPlayerSpawned = (Action)Delegate.Combine(Player.onLocalPlayerSpawned, new Action(this.RunStartupCommands));
		}
		
		
		
		/// <summary>Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and manipulate lists.</summary>
	/// <typeparam name="T">The type of elements in the list.</typeparam>
	// Token: 0x020004DC RID: 1244
	[DebuggerTypeProxy(typeof(Mscorlib_CollectionDebugView<>))]
	[DebuggerDisplay("Count = {Count}")]
	[__DynamicallyInvokable]
	[Serializable]
	public class List<T> : IList<T>, ICollection<!0>, IEnumerable<!0>, IEnumerable, IList, ICollection, IReadOnlyList<T>, IReadOnlyCollection<T>
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Collections.Generic.List`1" /> class that is empty and has the default initial capacity.</summary>
		// Token: 0x06003AEC RID: 15084 RVA: 0x000DFBD9 File Offset: 0x000DDDD9
		[__DynamicallyInvokable]
		public List()
		{
			this._items = List<T>._emptyArray;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Collections.Generic.List`1" /> class that is empty and has the specified initial capacity.</summary>
		/// <param name="capacity">The number of elements that the new list can initially store.</param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="capacity" /> is less than 0.</exception>
		// Token: 0x06003AED RID: 15085 RVA: 0x000DFBEC File Offset: 0x000DDDEC
		[__DynamicallyInvokable]
		public List(int capacity)
		{
			if (capacity < 0)
			{
				ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);
			}
			if (capacity == 0)
			{
				this._items = List<T>._emptyArray;
				return;
			}
			this._items = new T[capacity];
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Collections.Generic.List`1" /> class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.</summary>
		/// <param name="collection">The collection whose elements are copied to the new list.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="collection" /> is <see langword="null" />.</exception>
		// Token: 0x06003AEE RID: 15086 RVA: 0x000DFC1C File Offset: 0x000DDE1C
		[__DynamicallyInvokable]
		public List(IEnumerable<T> collection)
		{
			if (collection == null)
			{
				ThrowHelper.ThrowArgumentNullException(ExceptionArgument.collection);
			}
			ICollection<T> collection2 = collection as ICollection<T>;
			if (collection2 == null)
			{
				this._size = 0;
				this._items = List<T>._emptyArray;
				foreach (T item in collection)
				{
					this.Add(item);
				}
				return;
			}
			int count = collection2.Count;
			if (count == 0)
			{
				this._items = List<T>._emptyArray;
				return;
			}
			this._items = new T[count];
			collection2.CopyTo(this._items, 0);
			this._size = count;
		}

		/// <summary>Gets or sets the total number of elements the internal data structure can hold without resizing.</summary>
		/// <returns>The number of elements that the <see cref="T:System.Collections.Generic.List`1" /> can contain before resizing is required.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <see cref="P:System.Collections.Generic.List`1.Capacity" /> is set to a value that is less than <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
		/// <exception cref="T:System.OutOfMemoryException">There is not enough memory available on the system.</exception>
		// Token: 0x170008F4 RID: 2292
		// (get) Token: 0x06003AEF RID: 15087 RVA: 0x000DFCC4 File Offset: 0x000DDEC4
		// (set) Token: 0x06003AF0 RID: 15088 RVA: 0x000DFCD0 File Offset: 0x000DDED0
		[__DynamicallyInvokable]
		public int Capacity
		{
			[__DynamicallyInvokable]
			get
			{
				return this._items.Length;
			}
			[__DynamicallyInvokable]
			set
			{
				if (value < this._size)
				{
					ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.value, ExceptionResource.ArgumentOutOfRange_SmallCapacity);
				}
				if (value != this._items.Length)
				{
					if (value > 0)
					{
						T[] array = new T[value];
						if (this._size > 0)
						{
							Array.Copy(this._items, 0, array, 0, this._size);
						}
						this._items = array;
						return;
					}
					this._items = List<T>._emptyArray;
				}
			}
		}

		/// <summary>Gets the number of elements contained in the <see cref="T:System.Collections.Generic.List`1" />.</summary>
		/// <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.List`1" />.</returns>
		// Token: 0x170008F5 RID: 2293
		// (get) Token: 0x06003AF1 RID: 15089 RVA: 0x000DFD35 File Offset: 0x000DDF35
		[__DynamicallyInvokable]
		public int Count
		{
			[__DynamicallyInvokable]
			get
			{
				return this._size;
			}
		}

		/// <summary>Gets a value indicating whether the <see cref="T:System.Collections.IList" /> has a fixed size.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Collections.IList" /> has a fixed size; otherwise, <see langword="false" />.  In the default implementation of <see cref="T:System.Collections.Generic.List`1" />, this property always returns <see langword="false" />.</returns>
		// Token: 0x170008F6 RID: 2294
		// (get) Token: 0x06003AF2 RID: 15090 RVA: 0x000DFD3D File Offset: 0x000DDF3D
		[__DynamicallyInvokable]
		bool IList.IsFixedSize
		{
			[__DynamicallyInvokable]
			get
			{
				return false;
			}
		}

		// Token: 0x170008F7 RID: 2295
		// (get) Token: 0x06003AF3 RID: 15091 RVA: 0x000DFD40 File Offset: 0x000DDF40
		[__DynamicallyInvokable]
		bool ICollection<!0>.IsReadOnly
		{
			[__DynamicallyInvokable]
			get
			{
				return false;
			}
		}

		/// <summary>Gets a value indicating whether the <see cref="T:System.Collections.IList" /> is read-only.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Collections.IList" /> is read-only; otherwise, <see langword="false" />.  In the default implementation of <see cref="T:System.Collections.Generic.List`1" />, this property always returns <see langword="false" />.</returns>
		// Token: 0x170008F8 RID: 2296
		// (get) Token: 0x06003AF4 RID: 15092 RVA: 0x000DFD43 File Offset: 0x000DDF43
		[__DynamicallyInvokable]
		bool IList.IsReadOnly
		{
			[__DynamicallyInvokable]
			get
			{
				return false;
			}
		}

		/// <summary>Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).</summary>
		/// <returns>
		///   <see langword="true" /> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, <see langword="false" />.  In the default implementation of <see cref="T:System.Collections.Generic.List`1" />, this property always returns <see langword="false" />.</returns>
		// Token: 0x170008F9 RID: 2297
		// (get) Token: 0x06003AF5 RID: 15093 RVA: 0x000DFD46 File Offset: 0x000DDF46
		[__DynamicallyInvokable]
		bool ICollection.IsSynchronized
		{
			[__DynamicallyInvokable]
			get
			{
				return false;
			}
		}

		/// <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</summary>
		/// <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.  In the default implementation of <see cref="T:System.Collections.Generic.List`1" />, this property always returns the current instance.</returns>
		// Token: 0x170008FA RID: 2298
		// (get) Token: 0x06003AF6 RID: 15094 RVA: 0x000DFD49 File Offset: 0x000DDF49
		[__DynamicallyInvokable]
		object ICollection.SyncRoot
		{
			[__DynamicallyInvokable]
			get
			{
				if (this._syncRoot == null)
				{
					Interlocked.CompareExchange<object>(ref this._syncRoot, new object(), null);
				}
				return this._syncRoot;
			}
		}

		/// <summary>Gets or sets the element at the specified index.</summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <returns>The element at the specified index.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="index" /> is less than 0.  
		/// -or-  
		/// <paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
		// Token: 0x170008FB RID: 2299
		[__DynamicallyInvokable]
		public T this[int index]
		{
			[__DynamicallyInvokable]
			get
			{
				if (index >= this._size)
				{
					ThrowHelper.ThrowArgumentOutOfRangeException();
				}
				return this._items[index];
			}
			[__DynamicallyInvokable]
			set
			{
				if (index >= this._size)
				{
					ThrowHelper.ThrowArgumentOutOfRangeException();
				}
				this._items[index] = value;
				this._version++;
			}
		}

		// Token: 0x06003AF9 RID: 15097 RVA: 0x000DFDB4 File Offset: 0x000DDFB4
		private static bool IsCompatibleObject(object value)
		{
			return value is T || (value == null && default(T) == null);
		}

		/// <summary>Gets or sets the element at the specified index.</summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <returns>The element at the specified index.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />.</exception>
		/// <exception cref="T:System.ArgumentException">The property is set and <paramref name="value" /> is of a type that is not assignable to the <see cref="T:System.Collections.IList" />.</exception>
		// Token: 0x170008FC RID: 2300
		[__DynamicallyInvokable]
		object IList.this[int index]
		{
			[__DynamicallyInvokable]
			get
			{
				return this[index];
			}
			[__DynamicallyInvokable]
			set
			{
				ThrowHelper.IfNullAndNullsAreIllegalThenThrow<T>(value, ExceptionArgument.value);
				try
				{
					this[index] = (T)((object)value);
				}
				catch (InvalidCastException)
				{
					ThrowHelper.ThrowWrongValueTypeArgumentException(value, typeof(T));
				}
			}
		}

		/// <summary>Adds an object to the end of the <see cref="T:System.Collections.Generic.List`1" />.</summary>
		/// <param name="item">The object to be added to the end of the <see cref="T:System.Collections.Generic.List`1" />. The value can be <see langword="null" /> for reference types.</param>
		// Token: 0x06003AFC RID: 15100 RVA: 0x000DFE38 File Offset: 0x000DE038
		[__DynamicallyInvokable]
		public void Add(T item)
		{
			if (this._size == this._items.Length)
			{
				this.EnsureCapacity(this._size + 1);
			}
			T[] items = this._items;
			int size = this._size;
			this._size = size + 1;
			items[size] = item;
			this._version++;
		}

		/// <summary>Adds an item to the <see cref="T:System.Collections.IList" />.</summary>
		/// <param name="item">The <see cref="T:System.Object" /> to add to the <see cref="T:System.Collections.IList" />.</param>
		/// <returns>The position into which the new element was inserted.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="item" /> is of a type that is not assignable to the <see cref="T:System.Collections.IList" />.</exception>
		// Token: 0x06003AFD RID: 15101 RVA: 0x000DFE90 File Offset: 0x000DE090
		[__DynamicallyInvokable]
		int IList.Add(object item)
		{
			ThrowHelper.IfNullAndNullsAreIllegalThenThrow<T>(item, ExceptionArgument.item);
			try
			{
				this.Add((T)((object)item));
			}
			catch (InvalidCastException)
			{
				ThrowHelper.ThrowWrongValueTypeArgumentException(item, typeof(T));
			}
			return this.Count - 1;
		}
		
		
		WHAT IS ABSTRACT CLASS? EXECUTE() LOOK INTERESTING :EYES: CAN YOU FIGURE OUT IN YOUR DNSPY CODE?
		
		class ScheduleOne.Console.ConsoleCommand (INSPECT IT!)
		
		// Token: 0x02000240 RID: 576
		public abstract class ConsoleCommand
		{
			// Token: 0x17000266 RID: 614
			// (get) Token: 0x06000C2F RID: 3119
			public abstract string CommandWord { get; }

			// Token: 0x17000267 RID: 615
			// (get) Token: 0x06000C30 RID: 3120
			public abstract string CommandDescription { get; }

			// Token: 0x17000268 RID: 616
			// (get) Token: 0x06000C31 RID: 3121
			public abstract string ExampleUsage { get; }

			// FIND THIS IN DNSPY ! HOW IT IS DEFINED/CALLED? ABSTRACT? EXPLAIN!!!
			// INVESTIGATE FOR PATCH & SEND CONSOLE INPUT FROM USER VIA GAME TO THE BRIDGE, WHO WILL BE DESIGNED TO KNOW OUR COMMANDS
			// ALSO INVESTIGATE OTHER CANDIDATES & SUMMARIZE ON ACTIVE PR YOU WORK ON
			// WE KNOW WHERE TO FIND IT'S LIST OF COMMANDS IN GAME! COMPARE THEIR LIST TO OURS ! WE DO NOT HANDLE THEIRS , WE HANDLE OURS AND LOG THEIRS :)
			// ALL GO ACROSS BRIDGE TO Console.cs
			// Token: 0x06000C32 RID: 3122
			public abstract void Execute(List<string> args);
		}
		
		// WE HAVE IT IN THIS FILE AND YOUR DNSPY ASSEMBLIES (THE PROJECT!), GO FORTH AND PROSPER BROSKII :P